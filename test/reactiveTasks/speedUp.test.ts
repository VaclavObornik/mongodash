import { noop } from 'lodash';
import { Collection, Document } from 'mongodb';
import { createSandbox } from 'sinon';
import { ReactiveTaskScheduler } from '../../src/reactiveTasks/index';
import { getNewInstance } from '../testHelpers';

describe('Reactive Tasks SpeedUp', () => {
    let instance: ReturnType<typeof getNewInstance>;
    let scheduler: ReactiveTaskScheduler;
    let sourceCollection: Collection<Document>;

    beforeEach(async () => {
        instance = getNewInstance();
        await instance.initInstance({
            onError: noop,
            onInfo: noop,
        });
        sourceCollection = instance.mongodash.getCollection('speedup_source');

        // Access the scheduler instance (it's a singleton in index.ts, but we want a fresh one if possible,
        // or we use the exported class to create a new one for testing if exported)
        // We need to require it here to get the version that uses the initialized mongo client from getNewInstance
        const { ReactiveTaskScheduler } = require('../../src/reactiveTasks/index');
        scheduler = new ReactiveTaskScheduler();
        scheduler.configure({ reactiveTaskConcurrency: 2 });
        (scheduler as any).internalOptions.minPollMs = 5000; // Long poll to verify speedUp works
        (scheduler as any).internalOptions.maxPollMs = 10000;

        // Mock globals collection for the new scheduler instance
        (scheduler as any).globalsCollection = instance.mongodash.getCollection('globals');
        // We need to init the scheduler with the globals collection manually or via init()
        // But init() sets the singleton.
        // Let's just set the private property as we did above.
    }, 10000);

    afterEach(async () => {
        await scheduler.stop();
        await instance.cleanUpInstance();
    });

    const sandbox = createSandbox();
    afterEach(() => sandbox.verifyAndRestore());

    it('should trigger speedUp when a task is planned', async () => {
        const taskName = 'speedUpTask';
        const debounce = 200;

        await scheduler.addTask({
            task: taskName,
            collection: sourceCollection,
            debounce: debounce,
            handler: async () => {
                // noop
            },
        });

        await scheduler.start();

        // Spy on speedUp
        // We need to wait for start() to initialize concurrentRunner
        const concurrentRunner = (scheduler as any).concurrentRunner;
        const speedUpSpy = sandbox.spy(concurrentRunner, 'speedUp');

        // Insert a document to trigger planning
        await sourceCollection.insertOne({ value: 1 });

        // Wait for debounce + buffer
        // Planning happens async via change stream.
        // Batch interval is 500ms (default).
        // Debounce is 200ms.
        // So we expect:
        // 1. Change stream event (immediate)
        // 2. Batch flush (max 500ms)
        // 3. Planning pipeline execution
        // 4. onTaskPlanned called -> setTimeout(200ms)
        // 5. speedUp called

        // Total wait: 500 + 200 + buffer = ~1000ms
        await new Promise((resolve) => setTimeout(resolve, 1500));

        // Verify speedUp was called
        // The argument to speedUp should be the tasks collection name
        // We don't know the exact name generated by registry, but we can check if it was called with a string
        expect(speedUpSpy.called).toBe(true);
        const calledArg = speedUpSpy.firstCall.args[0];
        expect(typeof calledArg).toBe('string');
        expect(calledArg).toContain('speedup_source_tasks'); // Default naming is sourceCollection + '_tasks'
    });
});
